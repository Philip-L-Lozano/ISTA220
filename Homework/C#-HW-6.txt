### Philip Lozano
### C# Homework 6
### 27 January 2021

1. The C# language's exception handling features help you deal with any unexpected or exceptional 
situations that occur when a program is running. Exception handling uses the try, catch, and finally 
keywords to try actions that may not succeed, to handle failures when you decide that it's reasonable 
to do so, and to clean up resources afterward. Exceptions can be generated by the common language 
runtime (CLR), by .NET or third-party libraries, or by application code. Exceptions are created by 
using the throw keyword.

2. If all statements in the try block execute and none of the statements generates an
exception, they all run, one after the other, to completion.

3. Notice that after catching an exception, execution continues in the method containing the catch 
block that caught the exception. If the exception occurred in a method other than the one containing 
the catch handler, control does not return to the method that caused the exception.

4. If no handler corresponds to the exception, the exception is said to be unhandled. The application 
stops at the statement that caused the exception and drops you into the debugger. There you can examine 
the values of variables, you can change the values of variables, and you can step through your code 
from the point at which the exception occurred by using the Debug toolbar and the various debug windows.

5. The Exception class is the parent class of all exceptions. When an error occurs, either the system 
or the currently executing application reports it by throwing an exception that contains information 
about the error. After an exception is thrown, it is handled by the application or by the default 
exception handler.

6. The application stops at the statement that caused the exception and drops you into the debugger.
There you can examine the values of variables, you can change the values of variables, and you can step
through your code from the point at which the exception occurred by using the Debug toolbar and the
various debug windows.

7. Overflow checking on integer expressions prevents numeric values from being overloaded and delivering
false values when dealing with very high numbers that exceed their fixed value ranges.

8. The *signed* INT32 range is â€“2147483648 to 2147483647

9. The .NET Framework also includes an *unsigned* 32-bit integer value type, **UInt32**, which represents 
values that range from 0 to 4,294,967,295. Unsigned integers can represent only positive numbers and 0. 
Unsigned integers can represent more values because they do not take up a bit to sign the integer.

10. The way to ensure that a statement is always run, whether or not an exception has been thrown,
is to write that statement inside a finally block. A finally block occurs immediately after a try block or
immediately after the last catch handler after a try block. As long as the program enters the try block
associated with a finally block, the finally block will always be run, even if an exception occurs. If an
exception is thrown and caught locally, the exception handler executes first, followed by the finally
block. If the exception is not caught locally (that is, the runtime has to search through the list of call-
ing methods to find a handler), the finally block runs first. The important point is that the finally block
always executes.

11. You might not use a *finally* block if you want to stop and handle an exception immediately before
allowing the rest of the program to run.